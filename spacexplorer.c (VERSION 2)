#include <stdio.h> // This is used for standard input/output library functions such as "printf" and "scanf".
#include "spacexplorer.h" // This is used as it is the Custom Header File to this game.

void displayGrid(Player *player, Asteroid asteroids[], Junk junk[], int junkCount, int asteroidCount) { // Function to display the grid with player, asteroids and junk.
 for (int y = 0; y < GRID_SIZE; y++) { // For loop to go through each row of the grid.
 for (int x = 0; x < GRID_SIZE; x++) { // For loop to go through each column of the grid.
            if (player->pos.x == x && player->pos.y == y) // For loop to check where the player's position currently is...
                printf("P "); // ... when this is found "P" is printed for the player's position.
            else {
                int found = 0; // This is used to check if something is at this position.
                // Lines 17-22 checks for asteroids in this position.
                for (int i = 0; i < asteroidCount; i++) { // For loop through all asteroids.
                    if (asteroids[i].active && asteroids[i].pos.x == x && asteroids[i].pos.y == y) { // This line checks if the asteroid is active and its "x" and "y" coordinate matched the current grid position.
                        printf("A "); // Print "A" to show that an asteroid is in this position.
                        found = 1; // This line shows that something has been found this position.
                        break; // Exit loop once an asteroid has been found.
                    }
                }
                // If no asteroid have been found, check for junk
                if (!found) { // If no asteroid have been found at this position
                    for (int i = 0; i < junkCount; i++) { // For loop all junk items.
                        if (junk[i].active && junk[i].pos.x == x && junk[i].pos.y == y) { // This line checks if the junk is active and its "x" and "y" coordinates matches the grid position.
                            printf("J "); // Print "J" to show that junk is in this position.
                            found = 1; // This line shows that something has been found this position.
                            break; // Exit loop once an asteroid has been found.
                        }
                    }
                }
                if (!found) printf(". "); // If no asteroid or junk has been found then print ".".
            }
        }
        printf("\n"); // Move to a new line after printing an entire row of the grid.
    }
}

void movePlayer(Player *player, char direction) { // Function to move player based on the users input direction/
    // Lines 43 and 44 stores the current position
    int newX = player->pos.x;
    int newY = player->pos.y;

    // Lines 47-54 updates the position based on the direction the user enters:
    switch (direction) {
        case 'w': newY--; break; // When user presses 'w' then the co-ordinate "y" decreases and player moves UP
        case 's': newY++; break; // When user presses 's' then the co-ordinate "y" increases and player moves DOWN
        case 'a': newX--; break; // When user presses 'a' then the co-ordinate "x" decreases and player moves LEFT
        case 'd': newX++; break; // When user presses 'd' then the co-ordinate "x" increases and player moves RIGHT
        default:
            printf("Invalid input. Use w/a/s/d (w - Up, a - Left, s - Down, d - Right).\n"); // This is used if user enters another character (i.e. other than w/a/s/d).
            return;
    }

    // Lines 58-60 checks if the new position is within the grid boundaries:
    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
        printf("Move not possible, you are at the edge! Try again.\n"); // This line is printed if the user tries to exit out of the boundaries.
        return;
    }

    // Lines 64-66 updates the players position and reduces "-1" fuel each time.
    player->pos.x = newX;
    player->pos.y = newY;
    player->fuel--;
}

void moveAsteroids(Asteroid asteroids[], int asteroidCount) { // Function to move asteroids in their current direction.
    for (int i = 0; i < asteroidCount; i++) { // For loop to go through all the asteroids.
        if (!asteroids[i].active) continue; // This line skips past any inactive asteroids (i.e. if they are not asteroids).

        // Lines 74 and 75 stores the asteroids in the current position.
        int newX = asteroids[i].pos.x;
        int newY = asteroids[i].pos.y;

        // Lines 78-82 updates the position based on the direction:
        switch (asteroids[i].direction) {
            case UP: newY--; break; // Co-ordinate "y" decreases which makes the position go UP
            case DOWN: newY++; break; // // Co-ordinate "y" increases which makes the position go DOWN
            case LEFT: newX--; break; // // Co-ordinate "x" decreases which makes the position go LEFT
            case RIGHT: newX++; break; // // Co-ordinate "y" increases which makes the position go RIGHT
        }

        if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) { // If any of the asteroids are going to move outside of the grid...
            asteroids[i].direction = rand() % 4; // ... The asteroids would then go a random new direction.
        } else {

            // ... Lines 90-91 updates the new position
            asteroids[i].pos.x = newX;
            asteroids[i].pos.y = newY;
        }
    }
}

int checkCollision(Player *player, Asteroid asteroids[], int asteroidCount) { // Function used to check if the player collides with any of the asteroids.
    for (int i = 0; i < asteroidCount; i++) { // For loop to go through each of the asteroids.
        // Lines 99-101 checks if the asteroid is active and in the same position as the player
        if (asteroids[i].active &&
            player->pos.x == asteroids[i].pos.x &&
            player->pos.y == asteroids[i].pos.y) {
            return 1; // If it is then collision has occurred.
        }
    }
    return 0; // If not then collision has not occurred.
}

void collectJunk(Player *player, Junk junk[], int *junkCount) { // Function to collect junk at player's position
    for (int i = 0; i < *junkCount; i++) { // For loop to go through all the junk items.
        if (junk[i].active && junk[i].pos.x == player->pos.x && junk[i].pos.y == player->pos.y) { // This line checks to see if the junk is active and is at the same position as the player.
            junk[i].active = 0; // If it is... deactivate the junk.
            player->junkCollected++; // Increment collected junk.
            player->fuel += 3; // Increment fuel by 3.
            if (player->fuel > 100) player->fuel = 100; // Fuel is capped at 100.
            player->health += 1; // Increment health by 1.
            if (player->health > 100) player->health = 100; // Health is capped at 100.
        }
    }
}
